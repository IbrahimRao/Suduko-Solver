# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PNQcwCFsOVIsjtq_r1j5vB771r84ptQV
"""

import random

"""#### Problem 1: 9x9 Sudoku Puzzle

##### Simple Recursive Backtracking
"""

def isValid (board, row, col, num):
    for i in range(9):
        if board[row][i] == num:
            return False
        if board[i][col] == num:
            return False
    startRow = row - row % 3
    startCol = col - col % 3
    for i in range(3):
        for j in range(3):
            if board[i + startRow][j + startCol] == num:
                return False
    return True

def solveSudoku (board,r=0,c=0):
    if r == 9:
        return True
    elif c == 9:
        return solveSudoku(board,r+1,0)
    elif board[r][c] != 0:
        return solveSudoku(board,r,c+1)
    else:
        for i in range(1,10):
            if isValid(board,r,c,i):
                board[r][c] = i
                if solveSudoku(board,r,c+1):
                    return True
                board[r][c] = 0
        return False




def printBoard (board):
    for i in range(9):
        for j in range(9):
            print(board[i][j], end = " ")
        print()

"""#### Backtracking with MRV"""

def get_empty_cells(grid):
    empty_cells = []
    for i in range(9):
        for j in range(9):
            if grid[i][j] == 0:
                empty_cells.append((i, j))
    return empty_cells

def get_remaining_values_count(grid, row, col):
    values = set(range(1, 10))
    for i in range(9):
        values.discard(grid[row][i])  # Remove values in the same row
        values.discard(grid[i][col])  # Remove values in the same column
    subgrid_row, subgrid_col = (row // 3) * 3, (col // 3) * 3
    for i in range(3):
        for j in range(3):
            values.discard(grid[subgrid_row + i][subgrid_col + j])  # Remove values in the same subgrid
    return len(values), values

def get_index_with_minimum_remaining_values(grid):
    empty_cells = get_empty_cells(grid)
    min_remaining_values = float('inf')
    min_index = None
    min_values = None
    for row, col in empty_cells:
        remaining_values_count, values = get_remaining_values_count(grid, row, col)
        if remaining_values_count < min_remaining_values:
            min_remaining_values = remaining_values_count
            min_values = values
            min_index = (row, col)
    return min_index, min_values


def solveSudokuWithMRV (board,r=0,c=0):
    index, values = get_index_with_minimum_remaining_values(board)
    if index == None:
        return True

    r, c = index

    for i in values:
        if isValid(board,r,c,i):
            board[r][c] = i
            if solveSudokuWithMRV(board):
                return True
            board[r][c] = 0
    return False

"""#### Backtracking with MRV and Degree Heuristic"""

def calculate_degree_heuristic(grid, row, col):
    def count_empty_cells_in_row(grid, row):
        return sum(1 for j in range(9) if grid[row][j] == 0)

    def count_empty_cells_in_col(grid, col):
        return sum(1 for i in range(9) if grid[i][col] == 0)

    def count_empty_cells_in_subgrid(grid, row, col):
        subgrid_row, subgrid_col = (row // 3) * 3, (col // 3) * 3
        return sum(1 for i in range(subgrid_row, subgrid_row + 3) for j in range(subgrid_col, subgrid_col + 3) if grid[i][j] == 0)

    row_empty_cells = count_empty_cells_in_row(grid, row)
    col_empty_cells = count_empty_cells_in_col(grid, col)
    subgrid_empty_cells = count_empty_cells_in_subgrid(grid, row, col)

    total_empty_cells = row_empty_cells + col_empty_cells + subgrid_empty_cells
    return total_empty_cells

def get_min_index(grid):
    empty_cells = get_empty_cells(grid)
    min_remaining_values = float('inf')
    min_index = None
    min_values = None
    for row, col in empty_cells:
        remaining_values_count, values = get_remaining_values_count(grid, row, col)
        if remaining_values_count < min_remaining_values:
            min_remaining_values = remaining_values_count
            min_values = values
            min_index = (row, col)
        elif remaining_values_count == min_remaining_values:
            if calculate_degree_heuristic(grid, row, col) > calculate_degree_heuristic(grid, min_index[0], min_index[1]):
                min_remaining_values = remaining_values_count
                min_values = values
                min_index = (row, col)

    return min_index, min_values

def solveWithMRVandDHeuristic (board,r=0,c=0):
    index, values = get_min_index(board)
    if index == None:
        return True

    r, c = index

    for i in values:
        if isValid(board,r,c,i):
            board[r][c] = i
            if solveSudokuWithMRV(board):
                return True
            board[r][c] = 0
    return False

"""#### With LCV implemented as well"""

def get_candidate_values(grid, row, col):
    # Set of values that cannot be placed in the cell (row, col)
    if grid[row][col] != 0:
        return []
    invalid_values = set()

    # Check values in the same row
    for j in range(9):
        if grid[row][j] != 0:
            invalid_values.add(grid[row][j])

    # Check values in the same column
    for i in range(9):
        if grid[i][col] != 0:
            invalid_values.add(grid[i][col])

    # Check values in the same 3x3 subgrid
    subgrid_row, subgrid_col = (row // 3) * 3, (col // 3) * 3
    for i in range(subgrid_row, subgrid_row + 3):
        for j in range(subgrid_col, subgrid_col + 3):
            if grid[i][j] != 0:
                invalid_values.add(grid[i][j])

    # Possible candidate values are the numbers 1 to 9 that are not in invalid_values
    candidate_values = [num for num in range(1, 10) if num not in invalid_values]

    return candidate_values

def get_neighboring_cells(row, col):
    neighbors = set()
    for i in range(9):
        if i != col:
            neighbors.add((row, i))  # Same row
        if i != row:
            neighbors.add((i, col))  # Same column

    subgrid_row, subgrid_col = (row // 3) * 3, (col // 3) * 3
    for i in range(subgrid_row, subgrid_row + 3):
        for j in range(subgrid_col, subgrid_col + 3):
            if i != row and j != col:
                neighbors.add((i, j))  # Same subgrid

    return neighbors

def select_value_with_lcv(grid, row, col, values):
    neighboring_cells = get_neighboring_cells(row, col)
    lcv_values = []

    for value in values:
        lcv_count = sum(1 for r, c in neighboring_cells if value in get_candidate_values(grid, r, c))
        lcv_values.append((value, lcv_count))

    # Sort candidate values by least constraining value (LCV)
    sorted_values = sorted(lcv_values, key=lambda x: x[1])

    return [value for value, _ in sorted_values]


def solveWithMRVandDHeuristicandLCV (board,r=0,c=0):
    index, values = get_min_index(board)
    if index == None:
        return True

    r, c = index


    # AC3 check
    for i in board:
        for j in i:
            if j == 0:
                values = get_candidate_values(board, r, c)
                if len(values) == 0:
                    return False

    values = select_value_with_lcv(board, r, c, values)
    for i in values:
        if isValid(board,r,c,i):
            board[r][c] = i
            if solveSudokuWithMRV(board):
                return True
            board[r][c] = 0
    return False

# Testing Grids
sudoku_grid_solved = [
    [6,1,3,2,9,8,4,7,5],
    [9,4,8,7,3,5,1,2,6],
    [7,5,2,1,4,6,8,9,3],
    [8,9,5,3,6,2,7,4,1],
    [2,6,1,5,7,4,3,8,9],
    [3,7,4,8,1,9,6,5,2],
    [1,3,9,4,2,7,5,6,8],
    [4,8,6,9,5,3,2,1,7],
    [5,2,7,6,8,1,9,3,4]

]


sudoku_grid = [
    [0, 1, 0, 2, 0, 8, 0, 0, 0],
    [0, 0, 0, 7, 0, 0, 0, 2, 6],
    [0, 0, 2, 1, 4, 0, 0, 9, 0],
    [0, 0, 0, 0, 0, 2, 7, 0, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [3, 0, 4, 8, 0, 0, 0, 0, 0],
    [0, 3, 0, 0, 2, 7, 5, 0, 0],
    [4, 8, 0, 0, 0, 3, 0, 0, 0],
    [0, 0, 0, 6, 0, 1, 0, 3, 0]
]

printBoard(sudoku_grid)

print(solveWithMRVandDHeuristicandLCV(sudoku_grid))
printBoard(sudoku_grid)
print(sudoku_grid == sudoku_grid_solved)

# Grid Generation
def generateSudoku (board, difficulty = 30):
    for i in range(9):
        for j in range(9):
            board[i][j] = random.randint(1,9)

    for i in range(difficulty):
        row = random.randint(0,8)
        col = random.randint(0,8)
        board[row][col] = 0


generateSudoku(sudoku_grid)
printBoard(sudoku_grid)

print(solveSudoku(sudoku_grid))
printBoard(sudoku_grid)

# Grid Generation using Backtracking algo to generate a solved grid which have at least one solution
def generateSudokuBackTracking (board, difficulty = 30):
    for i in range(9):
        for j in range(9):
            board[i][j] = 0

    solveSudoku(board)  # Change this function to use different implementations of backtracking to generate boards

    for i in range(difficulty):
        row = random.randint(0,8)
        col = random.randint(0,8)
        board[row][col] = 0



generateSudokuBackTracking(sudoku_grid)
printBoard(sudoku_grid)

solveSudoku(sudoku_grid)